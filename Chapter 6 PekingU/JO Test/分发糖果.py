
# 题目内容：
# 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

# 你需要按照以下要求，帮助老师给这些孩子分发糖果：
# 每个孩子至少分配到 1 个糖果。
# 相邻的孩子中，评分高的孩子必须获得更多的糖果。
# 那么这样下来，老师至少需要准备多少颗糖果呢？

# 输入格式:
# 一个列表，以文本格式的有效Python表达式给出

# 输出格式：
# 一行数字，表示满足分配条件所需的最少糖果数

# 输入样例：
# [1,2,2]

# 输出样例：
# 4
# 注：可行的分配方案为1、2、1 颗糖果；第三个孩子只得到1颗糖果也满足题目条件

# 示例代码模板：
# def candy(ratings):
#     # code here
#     pass

# lst = eval(input())
# print(candy(lst))

# 思路
# 最少的分配发案就是保证每位同学都比两边评分低的同学多一颗糖果，
# 先假设每一位同学都能分配一颗糖果，接着从前往后判断每一位同学评分是否比前一位高，
# 如果评分比前一位高就分配比前一位多一颗的糖果，否则保持糖果不变，
# 当遍历结束后就可以保证每位同学都比前边评分低的同学多一颗糖果，
# 接着从后往前判断每一位同学评分是否比后一位高，
# 如果评分比后一位高且糖果没有后一位多，就分配比后一位多一颗的糖果，否则保持糖果不变，
# 当遍历结束后就可以保证每位同学都比两边评分低的同学多一颗糖果

def candyNum(ratings):
    rewardList = [1] * len(ratings) # 假设每一位同学都能分配一颗糖果

    for i in range(1, len(ratings)): # 从前往后判断每一位同学评分是否比前一位高。从1开始才可以比较前ratings的一个数字
        if ratings[i] > ratings[i-1]: #如果评分比前一位高就分配比前一位多一颗的糖果，否则保持糖果不变
            rewardList[i] = rewardList[i-1] + 1
    for i in range(len(ratings) - 2, -1, -1): # 从后往前判断每一位同学评分是否比后一位高。从-2开始才能从后往前开始比较前一个rating的数字
        if ratings[i] > ratings[i+1] and rewardList[i] <= rewardList[i+1]: #如果评分比后一位高且糖果没有后一位多，就分配比后一位多一颗的糖果，否则保持糖果不变
            rewardList[i] = rewardList[i+1] + 1
    Sum = sum(rewardList)

    return Sum

lst = eval(input())
print(candyNum(lst))
